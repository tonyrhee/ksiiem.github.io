---
categories: [Theory, JavaBasic]
---

### 패키지

---

### 패키지(package)

- 자바에서 **`패키지(package)`**란 **`클래스와 인터페이스의 집합`**을 의미한다. 이렇게 서로 관련이 있는 클래스나 인터페이스를 함께 묶음으로써 파일을 효율적으로 관리할 수 있게 된다.
- 또한, 협업 시 서로 작업한 클래스 사이에서 발생할 수 있는 이름 충돌 문제까지도 패키지를 이용하면 피할 수 있다.
- 자바에서 패키지는 **`물리적으로 하나의 디렉터리`**를 의미한다. 따라서 `하나의 패키지에 속한 클래스나 인터페이스 파일`은 모두 **`해당 패키지 이름의 디렉터리에 포함`**되어 있다.
- 이러한 `패키지는 다른 패키지를 포함`할 수 있으며, 이때 **`디렉터리의 계층 구조는 점(.)으로 구분`**된다.

```java
// 자바에서 가장 많이 사용되는 패키지 중 하나인 String 클래스의 패키지 이름
java.lang.String
```

- 위의 예제에서 자바의 String 클래스는 java.lang 패키지에 속한 클래스라는 것을 알 수 있다.

---

### 패키지의 선언

- 자바에서 패키지를 선언하는 방법은 다음과 같다.

```java
// 문법
package 패키지이름;
```

- 위와 같은 명령문을 클래스나 인터페이스의 소스 파일에 추가하기만 하면 된다. 이때 **`패키지 이름`**에는 **`패키지의 경로까지 포함한 풀 네임을 명시`**해야 한다.

---

### 이름 없는 패키지(unnamed package)

- 자바의 `모든 클래스는 반드시 하나 이상의 패키지에 포함`되어야 한다.
- 하지만 자바 **`컴파일러는 소스 파일에 어떠한 패키지의 선언도 포함되지 않으면`**, 기본적으로 **`이름 없는 패키지(unnamed package)에 포함`**해 컴파일한다. 따라서 패키지를 명시하지 않은 모든 클래스와 인터페이스는 모두 같은 패키지에 포함되게 된다.

---

### import 문

- 위와 같이 선언한 패키지에 속한 클래스를 **`다른 파일에서 사용`**하기 위해서는 **`클래스 이름 앞에 패키지의 경로까지 포함한 풀 네임`**을 명시해 사용해야 한다. 하지만 클래스를 사용할 때마다 매번 이렇게 긴 이름을 사용하는 것은 비효율적이므로, 자바에서는 import 키워드를 별도로 제공하고 있다.
- **`import 문`**은 자바 컴파일러에 코드에서 사용할 **`클래스의 패키지에 대한 정보를 미리 제공`**하는 역할을 한다. 따라서 import 문을 사용하면 다른 패키지에 속한 클래스를 **`패키지 이름을 제외한 클래스 이름만으로 사용`**할 수 있게 된다.

---

### import 문의 선언

- 자바에서 import 문은 다음과 같이 선언할 수 있다.

```java
// 문법
1. import 패키지이름.클래스이름;
2. import 패키지이름.*;
```

- 패키지 이름에는 패키지의 경로까지 포함한 풀 네임을 명시해야 한다.
- 첫 번째 방법은 해당 패키지의 **`특정 클래스만`**을 사용하고자 할 때 사용한다. 두 번째 방법은 해당 패키지의 **`모든 클래스`**를 **`클래스 이름만으로 사용`**하고 싶을 때 사용한다.

---

### import 문의 특징

- import 문을 선언할 때 별표(`*`)를 사용하는 것이 해당 패키지에 포함된 다른 모든 하위 패키지의 클래스까지 포함해 주는 것은 아니다.

```java
// 문법
import java.awt.*;
import java.util.*;
```

- 즉, 위와 같은 두 개의 import 문을 아래와 같이 하나의 import 문으로 표현할 수는 없다.

```java
// 문법
import java.*;
```

- 또한, 자바에서는 가장 많이 사용하는 **`java.lang 패키지`**에 대해서는 **`import 문을 사용하지 않아도 클래스 이름만으로 사용`**할 수 있도록 해주고 있다.


<br>
### 접근 제어자

---

### 제어자(modifier)

- **<mark>제어자(modifier)</mark>**란 **<mark>클래스와 클래스 멤버의 선언 시 사용</mark>**하여 <mark>부가적인 의미를 부여하는 키워드</mark>를 의미한다.
- 자바에서 제어자는 <mark>접근 제어자(access modifier)</mark>와 <mark>기타 제어자로 구분</mark>할 수 있다.
- 기타 제어자는 경우에 따라 여러 개를 함께 사용할 수도 있지만, **<mark>접근 제어자를 두 개 이상 같이 사용할 수는 없다</mark>**. 이러한 접근 제어자와 기타 제어자는 조합에 따라 함께 사용할 수 있다.

---

### 접근 제어자(access modifier)

- 객체 지향에서 **<mark>정보 은닉(data hiding)</mark>**이란 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다는 개념이다. 그렇게 함으로써 사용자는 언제나 최소한의 정보만으로 프로그램을 손쉽게 사용할 수 있게 된다.
- 자바에서는 이러한 정보 은닉을 위해 **<mark>접근 제어자(access modifier)</mark>**라는 기능을 제공하고 있다. 접근 제어자를 사용하면 **<mark>클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정</mark>**하여 **<mark>정보 은닉을 구체화</mark>**할 수 있다.
- 자바에서는 다음과 같은 네 가지의 접근 제어자를 제공한다.
    
    1. private
    
    2. public
    
    3. default
    
    4. protected
    

---

### private 접근 제어자

- private 접근 제어자를 사용하여 **<mark>선언된 클래스 멤버는 외부에 공개되지 않으며</mark>**, **<mark>외부에서는 직접 접근할 수 없다</mark>**.
- 즉, <mark>자바 프로그램은 private 멤버에 직접 접근할 수 없으며</mark>, **<mark>해당 객체의 public 메소드를 통해서만 접근</mark>**할 수 있다. 따라서 private 멤버는 <mark>public 인터페이스를 직접 구성하지 않고</mark>, <mark>클래스 내부의 세부적인 동작을 구현</mark>하는 데 사용된다.
- 다음 그림은 클래스의 private 멤버에 접근할 수 있는 영역을 보여준다.

![이미지](/assets/img/java_basic/%EC%A0%9C%EC%96%B4%EC%9E%90(1).png)

- 다음 예제처럼 private 멤버는 **<mark>해당 멤버를 선언한 클래스에서만 접근</mark>**할 수 있다.

```java
// 같은 클래스만 접근 허용
public class SameClass {
    private String var = "같은 클래스만 허용"; // private 필드
    private String getVar() { // private 메소드
        return this.var;
    }
}
```

---

### public 접근 제어자

- public 접근 제어자를 사용하여 **<mark>선언된 클래스 멤버는 외부로 공개</mark>**되며, **<mark>해당 객체를 사용하는 프로그램 어디에서나 직접 접근</mark>**할 수 있다.
- 자바 프로그램은 public 메소드를 통해서만 해당 객체의 private 멤버에 접근할 수 있다. 따라서 **<mark>public 메소드</mark>**는 **<mark>private 멤버와 프로그램 사이의 인터페이스(interface) 역할</mark>**을 수행한다고 할 수 있다.
- 다음 그림은 클래스의 public 멤버에 접근할 수 있는 영역을 보여준다.

![이미지](/assets/img/java_basic/%EC%A0%9C%EC%96%B4%EC%9E%90(2).png)


- 자바에서 public 멤버는 프로그램 어디에서 누구나 접근할 수 있다.

```java
// 누구나 접근 허용
public class Everywhere {
    public String var = "누구든지 허용"; // public 필드
    public String getVar() { // public 메소드
        return this.var;
    }
}
```

- 자바에서 클래스 내부에서 메서드나 변수를 사용할 때, `해당 메서드나 변수가 인스턴스 메서드/변수인지 정적(static) 메서드/변수인지에 따라` public 키워드를 붙이거나 생략할 수 있다.
    1. public 붙이는 경우
        - 메서드나 변수를 클래스 `외부에서도 사용`할 수 있도록 할 때, 즉, 해당 메서드나 변수가 클래스의 `인스턴스와 무관하게 공용으로 사용`되어야 할 때에 public 키워드를 붙인다.
    2. public 빼는 경우:
        - 메서드나 변수를 클래스의 내부에서만 사용하고 외부에서는 사용할 필요가 없는 경우에는 public 키워드를 생략한다. 이는 `해당 메서드나 변수가 클래스의 인스턴스와 관련`이 있거나, `클래스 내부에서만 사용`되어야 할 때이다.

---

### default 접근 제어

- 자바에서는 **<mark>클래스 및 클래스 멤버의 접근 제어의 기본값</mark>**으로 **<mark>default 접근 제어</mark>**를 별도로 명시하고 있다. 이러한 default를 위한 접근 제어자는 따로 존재하지 않으며, 접근 제어자가 지정되지 않으면 자동적으로 default 접근 제어를 가지게 된다.
- default 접근 제어를 가지는 멤버는 같은 클래스의 멤버와 **<mark>같은 패키지에 속하는 멤버에서만 접근</mark>**할 수 있다.
- 다음 그림은 클래스의 default 멤버에 접근할 수 있는 영역을 보여준다.

![이미지](/assets/img/java_basic/%EC%A0%9C%EC%96%B4%EC%9E%90(3).png)


- 다음 예제처럼 default 멤버는 같은 패키지에 속하는 클래스에서만 접근할 수 있다.

```java
// 같은 패키지만 접근 허용
package test;

public class SamePackage {
    String sameVar = "같은 패키지는 허용"; // default 필드
}
```

```java
// 같은 클래스도 접근 허용
package test;

public class SameClass {
    String var = "다른 패키지는 접근 불가"; // default 필드
    public static void main(String[] args) {
        SamePackage sp = new SamePackage();
        System.out.println(sp.sameVar); // 같은 패키지는 허용
    }
}
```

---

### protected 접근 제어자

- 자바 클래스는 <mark>private 멤버로 정보를 은닉</mark>하고, <mark>public 멤버로 사용자나 프로그램과의 인터페이스를 구축</mark>한다.
- 여기에 부모 클래스(parent class)와 관련된 접근 제어자가 하나 더 존재한다. protected 멤버는 <mark>부모 클래스에 대해서는 public 멤버</mark>처럼 취급되며, <mark>외부에서는 private 멤버처럼 취급</mark>된다.
- 클래스의 protected 멤버에 접근할 수 있는 영역은 다음과 같다.
    
    1. 이 멤버를 선언한 클래스의 멤버
    
    2. 이 멤버를 선언한 클래스가 속한 패키지의 멤버
    
    3. 이 멤버를 선언한 **<mark>클래스를 상속받은 자식 클래스(child class)의 멤버</mark>**
    
- 다음 그림은 클래스의 protected 멤버에 접근할 수 있는 영역을 보여준다.

![이미지](/assets/img/java_basic/%EC%A0%9C%EC%96%B4%EC%9E%90(4).png)


- 다음 예제처럼 protected 멤버는 같은 패키지에 속하는 클래스와 다른 패키지에 속하는 자식 클래스에서만 접근할 수 있다.

```java
// 같은 패키지는 접근 허용
package test;

public class SameClass {
    protected String sameVar = "다른 패키지에 속하는 자식 클래스까지 허용"; // protected 필드
}
```

```java
// 다른 패키지에 속하는 자식 클래스도 접근 허용
package test.other;
import test.SameClass; // test 패키지의 SameClass 클래스를 불러들여 포함시킨다.

public class ChildClass extends SameClass {
    public static void main(String[] args) {
        SameClass = new SameClass();
        System.out.println(sp.sameVar); // 다른 패키지에 속하는 자식 클래스까지 허용
    }
}
```

- 부모 클래스에 대한 더 자세한 사항은 자바 상속에서 확인할 수 있다.

---

### 접근 제어자의 접근 범위

- 자바에서 접근 제어자의 접근 범위가 보다 많은 제어자부터 적은 제어자 순으로 나열하면 다음과 같다.
    
    public > protected > default > private
    
- 이러한 접근 제어자의 접근 범위를 표로 표현하면 다음과 같다.

| 접근 제어자 | 같은 클래스의 멤버 | 같은 패키지의 멤버 | 자식 클래스의 멤버 | 그 외의 영역 |
| --- | --- | --- | --- | --- |
| public | ○ | ○ | ○ | ○ |
| protected | ○ | ○ | ○ | X |
| default | ○ | ○ | X | X |
| private | ○ | X | X | X |

- 자바에서는 클래스나 멤버를 선언할 때, 접근을 허용할 범위에 맞는 접근 제어자를 선택하는 것이 매우 중요하다.


<br>
### 기타 제어자

---

### final 제어자

- 자바에서 **`final 제어자`**는 **`'변경할 수 없다'`**는 의미로 사용된다. 즉, **<mark>필드나 지역 변수에 사용하면 값을 변경할 수 없는 상수(constant)</mark>**가 된다.
- 또한, 클래스에 사용하면 **<mark>해당 클래스는 다른 클래스가 상속받을 수 없게 된다</mark>**. 메소드에 사용하면 **<mark>해당 메소드는 오버라이딩(overriding)을 통한 재정의를 할 수 없게 된다</mark>**.
- 자바에서는 **`상속`**이라는 것을 통해 **`다른 클래스의 private 멤버를 제외한 모든 메소드를 상속`**받을 수 있다. 이렇게 상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 재정의하여 사용할 수도 있다. 메소드 오버라이딩(method overriding)이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미한다.
- 자바에서 final 제어자를 사용할 수 있는 대상은 다음과 같다.
  - **<mark>클래스, 메소드, 필드, 지역 변수</mark>**
    

```java
// 예제
final class Car {                    // 이 클래스는 상속을 통해 서브 클래스를 생성할 수 없다.
    final int VAR;                   // 이 필드는 상수화되어 값을 변경할 수 없다.
    final void brake() {             // 이 메소드는 오버라이딩을 통해 재정의할 수 없다.
    final double MAX_NUM = 10.2;     // 이 지역 변수는 상수화되어 값을 변경할 수 없다.
    }
}
```

---

### static 제어자

- 자바에서 **`static 제어자`**는 **`'공통적인'`**이라는 의미로 사용된다.
- 즉, static 제어자를 변수에 사용하면 해당 변수를 **<mark>클래스 변수</mark>**로 만들어 준다. 또한, 메소드에 사용하면 해당 메소드를 **<mark>클래스 메소드</mark>**로 만들어 준다. 이러한 static 제어자는 **<mark>초기화 블록</mark>**에도 사용할 수 있다.
- **`static 제어자를 가지는 멤버`**는 다음과 같은 특징을 가지게 된다.
    1. 프로그램 시작시 **`최초에 단 한 번만 생성되고 초기화`**된다.
    2. **`인스턴스를 생성하지 않고도 바로 사용`**할 수 있게 된다.
    3. 해당 클래스의 **`모든 인스턴스가 공유`**한다.

- 자바에서 static 제어자를 사용할 수 있는 대상은 다음과 같다.
  - **<mark>필드, 메소드, 초기화 블록</mark>**


```java
class Car {
    static int var;       // 클래스 필드(static 변수)
    static {              // static 초기화 블록
    // 보통 클래스 필드의 초기화를 진행한다.
    {
    static void brake() { // 클래스 메소드(static 메소드)
         ...
    }
}
```

- static 멤버의 특징에 대한 더 자세한 사항은 자바 클래스 멤버에서 확인할 수 있다.

---

### abstract 제어자

- 자바에서 **`abstract 제어자`**는 **`'추상적인'`**이라는 의미로 사용된다.
- **`선언부만 있고 구현부가 없는 메소드`**를 **<mark>추상 메소드</mark>**라 하며, 반드시 abstract 제어자를 붙여야 한다. 또한, **`하나 이상의 추상 메소드가 포함`**하고 있는 **<mark>추상 클래스</mark>**도 반드시 abstract 제어자를 붙여야 한다.
- 자바에서 abstract 제어자를 사용할 수 있는 대상은 다음과 같다.
  - **<mark>클래스, 메소드</mark>**
    

```java
abstract class Car {       // 추상 클래스
    abstract void brake(); // 추상 메소드
}
```

- 추상 클래스에 대한 더 자세한 사항은 자바 추상 클래스에서 확인할 수 있다.

---

### 제어자의 조합

- 자바에서는 접근 제어자와 기타 제어자를 한 대상에 함께 사용할 수 있다.
- 하지만 모든 경우가 가능한 것은 아니며, 대상에 따라 사용할 수 있는 조합은 다음과 같다.

| 대상 | 함께 사용할 수 있는 제어자 |
| --- | --- |
| 클래스 | public, (default), final, abstract |
| 메소드 | 모든 접근 제어자, final, static, abstract |
| 필드 | 모든 접근 제어자, final, static |
| 지역 변수 | final |
| 초기화 블록 | static |

- 또한, 자바에서는 제어자의 특성상 몇몇 제어자는 함께 사용할 수 없다.
    
    1. 클래스에 final과 abstract는 함께 사용할 수 없다.  
    final 제어자를 가지는 클래스는 다른 클래스가 상속받을 수 없게 되며, **`abstract 제어자를 가지는 클래스는 다른 클래스가 상속해서 오버라이딩`**해야만 사용할 수 있으므로, 이 두 제어자는 클래스에 함께 사용할 수 없다.
    
    2. 메소드에 static과 abstract는 함께 사용할 수 없다.  
    abstract 제어자를 가지는 메소드는 선언부만 있고 구현부가 없는 메소드인데, **`static 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용`**할 수 있어야 하므로, 이 두 제어자는 메소드에 함께 사용할 수 없다.
    
    3. 메소드에 private과 abstract는 함께 사용할 수 없다.  
    abstract 제어자를 가지는 메소드는 **`다른 클래스가 상속하여 오버라이딩`**해야만 사용할 수 있는데, **`private 제어자를 가지는 메소드는 자식 클래스에서 접근할 수 없게 되므로`**, 이 두 제어자는 메소드에 함께 사용할 수 없다.
    
    4. 메소드에 private과 final은 함께 사용할 필요가 없다.  
    메소드에 사용된 final 제어자와 private 제어자는 **`모두 해당 메소드가 오버라이딩을 통한 재정의를 할 수 없다`**는 의미를 가지므로, 둘 중에 하나만 사용해도 의미가 충분히 전달될 수 있다.